### 排序

冒泡排序：就是每次循环都将相邻的两个元素按照大小重写排序，而且每次循环，都会将最大的数字放到数组的尾部

时间复杂度：O(n^2)

选择排序：首先将未排序的数组中，最小(或最大)的值放到数组的起始位置(或末尾位置)。然后再循环遍历未排序的数组，将最小(或最大)的值放到已排序数组的末尾位置(或起始位置)

时间复杂度：O(n^2)

```
for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                if(nums[minIndex] > nums[j]){
                    minIndex = j;
                }
            }
            temp = nums[i];
            nums[i] = nums[minIndex];
            nums[minIndex] = temp;
        }
```



插入排序：对于未排序的数组，取出未排序数组中的第一个元素，然后再已排序的数组中进行扫描，将未排序元素插入已排序数组中相应的位置

时间复杂度：O(n^2)



归并排序：采用分治的思想，即先将每个子序列内元素排序，然后将子序列之间排序

时间复杂度：O(nlogn)



快速排序：从数组中选择一个数，然后将比这个数小的元素放到数组左边，将比这个数大的元素放到右边。然后分别对左右两个区间进行快速排序

时间复杂度：O(nlogn)



### LRU缓存：

大致思想就是，当从缓存中获取元素的时候，如果元素存在，则将元素移动带链表头部，否则将元素插入到链表头部，当链表满了以后，就将链表尾部不常用的元素移除，以节省空间