学习笔记
1,commit 脑图

1，线性表：代表数据是像一条线一样的结构，数组，链表，栈，队列都是线性表
     非线性表：代表性的有 二叉树，堆，图
2，数组：
      数组是一种线性表存储结构，在内存中是占用连续的内存空间，存储相同类型的一组数据。
      为什么数组会有根据下标随机访问元素的特性？
             答： 因为计算机会给每个内存单元分配一个内存地址，然后通过这个地址访问内存中的数据。当计算机想要随机访问数组中的某个元素的时候。会通过一个寻址公式，计算出该元素所在的内存地址。data_type_size为数组中每个元素的大小(例如存储的是int类型，则data_type_size为4个字节)。所以通过这个寻址公式，可以准确的找到第i个数组的内存地址，而不需要去遍历数组
                     寻址公式：a[i]_address = base_address + i * data_type_size （form 王争老师的数据结构与算法之美）
       数组的优点是可以根据下标随机访问数组中的元素，时间复杂度为O(1),那么缺点是什么呢？
             答：缺点就是插入删除的效率比较低，因为是连续的内存空间，所以在插入或者删除某个下标的元素时，往往意味着这个下标往后的所有元素都要整体的后移或者前移，这意味着每次都会有数据拷贝的发生。时间复杂度为O(n)
     
        技巧：比如要插入第k个元素，则把当前k位置的元素放到数组的最后，然后将新数据插入k这个位置，这样时间复杂度为O(1)，但是只在特定情况下可用
3，链表：
      链表不需要一块连续的数组空间，而是在内存中零散的存在着，它是通过指针将一组零散的内存块串联起来使用。链表所在的内存块可以称之为链表的节点，每个节点除了存储数据，还需要记录下一个节点的地址。记录下一个节点地址的指针称为后继指针，如果是双向链表的话，还需要记录上一个节点的地址，即前驱指针。
      链表的优缺点？
             答：优点是，插入的时候，时间复杂度是O(1)，因为插入的时候，只考虑相邻节点的指针指向的改变。而删除的时候，如果直接删除给定指针指向的元素，则为O(1),但是要删除节点中某个值等于给定的值，则首先要通过遍历找到这个值，这个时候，时间复杂度为O(n)，缺点是，如果想随机访问第k个元素，则需要遍历链表才可以。时间复杂度为O(n)，因为在内存中是不连续的，所以通过寻址公式无法直接找到元素对应的地址.
      双向链表和单向链表的区别？
             答：区别1，删除的时候，不管是删除节点中的某个值等于给定值，还是删除给定指针指向的某个节点，其实时间复杂度都有可能为O(n)，删除给定值需要遍历链表找到这个值，肯定为O(n)，但是删除给定指针指向的节点时，由于无法知道这个节点的上一个节点是谁，比如删除q，但是不知道p->next = q中的p节点，所以还需要遍历列表，直到找到p->next = q。 但是对于双向链表的时候，由于节点已经记录了前驱指针和后继指针，所以无需遍历
                    区别2，双向链表每个节点占用的内存空间比单链表大
                    区别3，双向链表，在查询的时候，可以记录上次查找的元素p的大小，然后和p比较，决定是往链表前面查询还是链表后面查询，可以节省时间
 
        数组和链表在缓存中的应用区别： 数组在内存上是连续的，可以借助CPU缓存机制，而链表对cpu缓存机制不友好

4，跳表：
             跳表是在链表的基础上，使用二分查找的思想，将每两个结点提取出来给一个上级结点，将提取出来的那个结点称为索引。而链表加多级索引的结构，就是跳表
             查询时间复杂度为O(logn)  空间复杂度为O(n)
             怎么保证跳表在插入删除操作后，还可以保持稳定的时间复杂度？
                    答：可以选择将元素插入到索引层中，通过一个随机函数，来决定插入到哪些索引层中，比如随机函数生成了值k，则就将这个节点添加带第一级到第k级这k级索引中

5，栈：
            栈是一个后进先出，先进后出的数据结构，只允许在一端插入和删除数据
6，队列：
            队列是一个先进先出的数据结构
            双端队列，是指队列两端都可以入队，出队
            优先队列，是指出队的时候，是按照一定的优先级出队的，内部使用的是堆式存储结构

本周心得：
   1，在做双端队列的时候，理解了双端队列，在一端不进行数据插入删除操作，只从另一端进行操作，那就可以看作是一个普通队列。
        在实现双端队列的时候，理解到了 计算head 和tail的时候，不能单纯的head-- ，tail++之类的，要使用取余(head = (head-1+length)%length  tail = (tail+1)%length)去规避数组越界的情况

   2，多次使用双指针解决算法题目的时候，熟悉了双指针的使用方法，
         一般都是一个块，一个慢，然后慢指针指向的元素和快指针指向的元素进行数学运算，得出想要的答案。
         还有一种就是三数之和时用到，两个指针，左中右三个数，两个指针分别指向中和右，中在左的下一位，右在数组的尾部。然后固定左数，中++和右-- 来计算三数之和，进行边界判断，减少时间复杂度

